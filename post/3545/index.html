<!doctype html><html lang dir=ltr>
<head><meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="终于迎来一期特刊。最近打算在公司内部做一个分享，讲的是组件化的设计与开发的思维方式。准备完演讲资料，发现这完全可以改成一篇文章。藏着掖着不合适，发出来分享给有需求的朋友吧，就当是个试讲了，希望大家帮忙指出错误。
下载地址： https://www.jianguoyun.com/p/Df4KevYQwKOaBhjO8r0EIAA
由于本文首先是以keynote的形式诞生的，其中还有动画和视频，所以我比较推荐大家直接下载keynote文件（也存了PPT版本）。内容和本文是一样的，但有些逻辑关系还真得让画面动起来才说得清。提醒一下，keynote文件大小将近150mb，嫌麻烦的朋友，当然也欢迎继续阅读。
组件化 组件化的工作方式信奉独立、完整、自由组合。目标就是尽可能把设计与开发中的元素独立化，使它具备完整的局部功能，通过自由组合来构成整个产品。
对于计算机这么复杂的工业产品，组件化是唯一能使它成为现实的方法。我中学暑假去电脑城打工，跟着别人学习电脑维修。CPU在哪里，负责什么，如何拆装；内存在哪里，负责什么，如何拆装。这些都是基础知识，各部分各司其职，什么坏了就换什么。我还见过资深维修工修主板，他真的能找出主板上哪个电容爆了，换一个相同规格的上去，电脑又能正常开机了。
对产品设计的意义 当然今天我们不讲电脑维修，组件化思维要运用到我们的工作中。首先要了解，它对设计和开发到底有什么意义？
这部分虽然讲的是设计，但对开发同学也有价值。你们能了解设计师在做设计时的思路，说直白点就是摸清楚我们的套路。其实我们做设计的时候会有系统的考虑，并不是天马行空，想一出是一出。
符合功能逻辑 组件化的设计恰恰是符合产品功能逻辑的。特定类型的信息，就有特定的最优展现方式和交互方式，这叫做设计模式。设计模式就应该提取出来作为组件。
比如要从多个维度快速检索和对比大量数据，没有什么能比表格形式效率更高。想象一下，上面这个界面的表格数据，做成卡片式堆叠在一起，划一张换一条，或者像淘宝商品列表那样，一行4列平铺开。那还对比个P啊，用户都要摔鼠标了。
保持交互一致性 交互的一致性，或者说可预测性，是用户体验的根本。比如日期选择组件，在整个产品中就应该只有一种存在形式。如果一会儿是滚轮拨盘，一会儿是日历，一会儿又是下拉列表，这样的设计绝对是不能上线的。
保持视觉风格统一 这部分主要是视觉方面的考虑，更多样式上的差异。不同的样式会给产品带来不同的调性。
就拿按钮来说。圆头造型表现出一种柔和亲切的特质，同时有利于将注意力聚焦到其中内容上。而直角则展现出一种棱角分明的硬朗，边界更加清晰。想一想三星手机和锤子手机的外观造型，两种截然不同的感觉。
为了保持产品视觉风格统一，设计师应该找到最合适的方案，并处处保持统一，不可以太随心所欲。
便于多设计师协作 组件化设计是大型设计项目的必要条件。比如两位设计师协作，一个在设计注册界面，一个在设计修改密码界面，或者在设计某个问卷调查的弹窗。这其中都有表单，两个人设计出来不一样怎么办？一个边框颜色深一点，一个边框颜色浅一点？其实没理由不同，应该保持一致。口头约定太麻烦，而且难以保证执行到位，组件化是最好的解决方式。
便于修改设计 设计总是要修改优化的，有些改动牵扯全局，动静非常大。
比如管理后台的界面，左侧的主导航是全站通用的。某天决定要给它换一套浅色的设计，难道每个PSD都改一遍吗？如果产品逻辑复杂，PSD有上百个呢？
对开发的意义 下面讲讲组件化对开发的意义。其实开发同学从中受益比设计师更多。
降低耦合度 降低耦合度，相信这是大型项目都在追求的。
举个例子，如果要把页面的body区域加宽。内部许多元素因为浮动、固定宽度、百分比宽度、文字行数减少等等，布局会乱套。就像这图里这样，这是因为内部模块的样式对页面父级元素存在依赖和继承。
可能有人会觉得并不存在依赖关系，但其实固定宽度本身就是一种依赖关系。假如说页面主体部分宽度1000px，左侧边栏200px，右侧800px。没错，这是按设计图来做的。那这个800px宽是怎么得出的？正是因为页面主体宽度1000px，才找了个合适的左右比例，设计成这样的。所以无可避免，从设计这个环节开始就产生了依赖关系。
像这种情况，我宁可在模块外面多套一层容器，模块本身的宽度写成100%，外面那层容器属于框架布局，具体宽度写在它上面。虽然DOM树变复杂了，但内外的布局逻辑被分离了。
减少冗余 比方说要新增一个带表格的界面，开发同学按照设计的效果图一行行写页面。但是如果在某个已有界面中就存在表格？或许当时是另一位开发同学做的。相比重新写一遍，把代码要过来直接用更方便一点吧？
如果表格样式之后又要改呢，是不是两个地方都得改。如此一来，用到表格的页面越多，就越容易漏改。而且静态资源服务器上存了太多份关于表格的样式，其中内容明明是一样的。
优化性能 优化性能刚好可以接着上一条说。
那么多份表格的样式，客户端每打开一个新的表格页面，就得加载一次。占用带宽，浪费了缓存资源。虽然一两个的影响几乎感受不到，但这种情况一多，就会对用户体验产生明显的影响。
慢，是用户体验的头等大忌，没有之一。
便于多开发协作 这和设计师协作的道理相同。
如果两个开发同学都在制作带有下拉菜单的页面，这部分工作只要交给其中一人就行了。TA做好之后封装成组件，另一位开发在自己的页面中加载就行了。
便于查错 便于查错，是耦合性降低的一个副产品。它可以大大加快错误排查的速度。
如果页面上出现问题，可以找出每个可能有关的组件，逐个拔除，直到恢复正常。这样就能迅速锁定错误发生的位置。同时组件内也可以形成完整的自测单元，也方便了测试工作。
便于修改 假如设计师每个页面改同一个地方要花一个小时，那开发做同样的事情至少要花一个上午，至少。
封装成组件，可以把这个时间缩短到10分钟。毕竟不用去改几十个页面的HTML、CSS和JS，改一个组件就可以了。
布局原理 讲了组件化的意义，本来顺理成章应该讲组件化的具体做法。但在这之前其实有必要插入这一块内容，帮助没有前端基础的设计师了解，开发是如何把页面搭建起来的。
大家可以先有一个粗略的想象，就像是重力朝上的俄罗斯方块。页面元素都是从下往上这样一行一行搭出来的，不过这个玩家有强迫症，他一定会从左上角、右上角或者中间位置搭起。当然……搭满一行并不会消除。 ¯\( ツ )/¯
行内元素与块元素 网页布局中有两个概念：行内元素和块元素。它们是非此即彼的关系，网页里只要是你能看见的东西，一定不是行内元素就是块元素。
这两种元素的表现略有不同。虚线框代表一行，但实际上这是不可见的，只是我为了说明布局方式画出来的，其中的绿色矩形才是页面上真实可见的元素。
我们看第一行，这里有3个行内元素。内容长度不同，它们表现出来的宽度就不同，这是一种会随内容变化而改变尺寸的布局单元，而且它们总是从左到右横向排列，只要一行里排得下。
再看第二行，这里只有1个块元素。你看它内容很短，就三个字，却占了一整行。没错，块元素就是这么任性。自习室一卷厕纸占一排座位。
最后看第三行。浅绿色是一个块元素，深绿色是它内部的元素。所以元素之间是可以嵌套的，无论多么复杂的页面，都是这样一层层嵌套形成的。但是要注意，块元素内可以嵌入行内元素和块元素，行内元素只能嵌入行内元素。请看其中的深绿色部分，第二行是一个块元素，设定了宽度，并且居中排列。其实前两个行内元素的右边明明有空间，而且右边还放得下一个行内元素。但即使如此，它还是要占一整行。
当然，块元素这个独占一行的特性有例外，我们接下来就会说。
浮动 刚才讲的是常规的布局方式，我们现在讲两种打破常规的方式。
浮动有两个方向，向左和向右。被加上了浮动属性的元素，表现都会变得类似于行内元素，根据内容变化尺寸。第一行的左右浮动元素都可以是块元素，但它们却排在了一行里。
第二行和第三行是一组对比，表现了非浮动元素与浮动元素混合排列时的规则。第二行的文字是一个常规布局的元素，可以看到左右浮动的元素各就各位，常规布局的文字很灵活地填充空隙，就像报纸排版一样。而第三行里的情况，文字段落也加上左浮动属性，并且限定宽度，它就会跟在左浮动元素的右侧。
当然，如果文字不限定宽度，它还是会独占一行，因为文字足够多。这和块元素独占一行的道理不同，它仍然带有浮动属性，本应该跟在左浮动元素的右边。只是因为自身宽度太大，一行挤不下了。
绝对定位 另一种打破常规的布局方式是绝对定位。这就毫无章法可言了，像狗皮膏药一样想贴哪里贴哪里，还可以像图里这样层叠着贴。总之，绝对定位的元素不会占据常规布局和浮动布局中的任何空间，而是直接挡住它背后的内容。
不过既然可以层叠，就有谁在前谁在后的问题。这和设计工具里的图层是一样的，当然有办法可以控制。
一个页面是如何搭建出来的 http://v.youku.com/v_show/id_XMjY0ODI3OTAyMA==.html"><title>组件化设计与开发</title><link rel=canonical href=../../post/3545/>
<link rel=stylesheet href=../../scss/style.min.8191399262444ab68b72a18c97392f5349be20a1615d77445be51e974c144cff.css><meta property="og:url" content="/post/3545/"><meta property="og:site_name" content="Victor42">
<meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2017-03-19T00:46:29Z"><meta property="article:modified_time" content="2017-03-19T00:46:29Z"><meta property="article:author" content="Victor42"><meta name=twitter:card content="summary_large_image">
<meta name=twitter:title content="组件化设计与开发">
<meta name=twitter:description content="终于迎来一期特刊。最近打算在公司内部做一个分享，讲的是组件化的设计与开发的思维方式。准备完演讲资料，发现这完全可以改成一篇文章。藏着掖着不合适，发出来分享给有需求的朋友吧，就当是个试讲了，希望大家帮忙指出错误。
下载地址： …">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"\/post\/3545\/"},"headline":"组件化设计与开发","description":"终于迎来一期特刊。最近打算在公司内部做一个分享，讲的是组件化的设计与开发的思维方式。准备完演讲资料，发现这完全可以改成一篇文章。藏着掖着不合适，发出来分享给有需求的朋友吧，就当是个试讲了，希望大家帮忙指出错误。\n下载地址： https:\/\/www.jianguoyun.com\/p\/Df4KevYQwKOaBhjO8r0EIAA\n由于本文首先是以keynote的形式诞生的，其中还有动画和视频，所以我比较推荐大家直接下载keynote文件（也存了PPT版本）。内容和本文是一样的，但有些逻辑关系还真得让画面动起来才说得清。提醒一下，keynote文件大小将近150mb，嫌麻烦的朋友，当然也欢迎继续阅读。\n组件化 组件化的工作方式信奉独立、完整、自由组合。目标就是尽可能把设计与开发中的元素独立化，使它具备完整的局部功能，通过自由组合来构成整个产品。\n对于计算机这么复杂的工业产品，组件化是唯一能使它成为现实的方法。我中学暑假去电脑城打工，跟着别人学习电脑维修。CPU在哪里，负责什么，如何拆装；内存在哪里，负责什么，如何拆装。这些都是基础知识，各部分各司其职，什么坏了就换什么。我还见过资深维修工修主板，他真的能找出主板上哪个电容爆了，换一个相同规格的上去，电脑又能正常开机了。\n对产品设计的意义 当然今天我们不讲电脑维修，组件化思维要运用到我们的工作中。首先要了解，它对设计和开发到底有什么意义？\n这部分虽然讲的是设计，但对开发同学也有价值。你们能了解设计师在做设计时的思路，说直白点就是摸清楚我们的套路。其实我们做设计的时候会有系统的考虑，并不是天马行空，想一出是一出。\n符合功能逻辑 组件化的设计恰恰是符合产品功能逻辑的。特定类型的信息，就有特定的最优展现方式和交互方式，这叫做设计模式。设计模式就应该提取出来作为组件。\n比如要从多个维度快速检索和对比大量数据，没有什么能比表格形式效率更高。想象一下，上面这个界面的表格数据，做成卡片式堆叠在一起，划一张换一条，或者像淘宝商品列表那样，一行4列平铺开。那还对比个P啊，用户都要摔鼠标了。\n保持交互一致性 交互的一致性，或者说可预测性，是用户体验的根本。比如日期选择组件，在整个产品中就应该只有一种存在形式。如果一会儿是滚轮拨盘，一会儿是日历，一会儿又是下拉列表，这样的设计绝对是不能上线的。\n保持视觉风格统一 这部分主要是视觉方面的考虑，更多样式上的差异。不同的样式会给产品带来不同的调性。\n就拿按钮来说。圆头造型表现出一种柔和亲切的特质，同时有利于将注意力聚焦到其中内容上。而直角则展现出一种棱角分明的硬朗，边界更加清晰。想一想三星手机和锤子手机的外观造型，两种截然不同的感觉。\n为了保持产品视觉风格统一，设计师应该找到最合适的方案，并处处保持统一，不可以太随心所欲。\n便于多设计师协作 组件化设计是大型设计项目的必要条件。比如两位设计师协作，一个在设计注册界面，一个在设计修改密码界面，或者在设计某个问卷调查的弹窗。这其中都有表单，两个人设计出来不一样怎么办？一个边框颜色深一点，一个边框颜色浅一点？其实没理由不同，应该保持一致。口头约定太麻烦，而且难以保证执行到位，组件化是最好的解决方式。\n便于修改设计 设计总是要修改优化的，有些改动牵扯全局，动静非常大。\n比如管理后台的界面，左侧的主导航是全站通用的。某天决定要给它换一套浅色的设计，难道每个PSD都改一遍吗？如果产品逻辑复杂，PSD有上百个呢？\n对开发的意义 下面讲讲组件化对开发的意义。其实开发同学从中受益比设计师更多。\n降低耦合度 降低耦合度，相信这是大型项目都在追求的。\n举个例子，如果要把页面的body区域加宽。内部许多元素因为浮动、固定宽度、百分比宽度、文字行数减少等等，布局会乱套。就像这图里这样，这是因为内部模块的样式对页面父级元素存在依赖和继承。\n可能有人会觉得并不存在依赖关系，但其实固定宽度本身就是一种依赖关系。假如说页面主体部分宽度1000px，左侧边栏200px，右侧800px。没错，这是按设计图来做的。那这个800px宽是怎么得出的？正是因为页面主体宽度1000px，才找了个合适的左右比例，设计成这样的。所以无可避免，从设计这个环节开始就产生了依赖关系。\n像这种情况，我宁可在模块外面多套一层容器，模块本身的宽度写成100%，外面那层容器属于框架布局，具体宽度写在它上面。虽然DOM树变复杂了，但内外的布局逻辑被分离了。\n减少冗余 比方说要新增一个带表格的界面，开发同学按照设计的效果图一行行写页面。但是如果在某个已有界面中就存在表格？或许当时是另一位开发同学做的。相比重新写一遍，把代码要过来直接用更方便一点吧？\n如果表格样式之后又要改呢，是不是两个地方都得改。如此一来，用到表格的页面越多，就越容易漏改。而且静态资源服务器上存了太多份关于表格的样式，其中内容明明是一样的。\n优化性能 优化性能刚好可以接着上一条说。\n那么多份表格的样式，客户端每打开一个新的表格页面，就得加载一次。占用带宽，浪费了缓存资源。虽然一两个的影响几乎感受不到，但这种情况一多，就会对用户体验产生明显的影响。\n慢，是用户体验的头等大忌，没有之一。\n便于多开发协作 这和设计师协作的道理相同。\n如果两个开发同学都在制作带有下拉菜单的页面，这部分工作只要交给其中一人就行了。TA做好之后封装成组件，另一位开发在自己的页面中加载就行了。\n便于查错 便于查错，是耦合性降低的一个副产品。它可以大大加快错误排查的速度。\n如果页面上出现问题，可以找出每个可能有关的组件，逐个拔除，直到恢复正常。这样就能迅速锁定错误发生的位置。同时组件内也可以形成完整的自测单元，也方便了测试工作。\n便于修改 假如设计师每个页面改同一个地方要花一个小时，那开发做同样的事情至少要花一个上午，至少。\n封装成组件，可以把这个时间缩短到10分钟。毕竟不用去改几十个页面的HTML、CSS和JS，改一个组件就可以了。\n布局原理 讲了组件化的意义，本来顺理成章应该讲组件化的具体做法。但在这之前其实有必要插入这一块内容，帮助没有前端基础的设计师了解，开发是如何把页面搭建起来的。\n大家可以先有一个粗略的想象，就像是重力朝上的俄罗斯方块。页面元素都是从下往上这样一行一行搭出来的，不过这个玩家有强迫症，他一定会从左上角、右上角或者中间位置搭起。当然……搭满一行并不会消除。 ¯\\( ツ )\/¯\n行内元素与块元素 网页布局中有两个概念：行内元素和块元素。它们是非此即彼的关系，网页里只要是你能看见的东西，一定不是行内元素就是块元素。\n这两种元素的表现略有不同。虚线框代表一行，但实际上这是不可见的，只是我为了说明布局方式画出来的，其中的绿色矩形才是页面上真实可见的元素。\n我们看第一行，这里有3个行内元素。内容长度不同，它们表现出来的宽度就不同，这是一种会随内容变化而改变尺寸的布局单元，而且它们总是从左到右横向排列，只要一行里排得下。\n再看第二行，这里只有1个块元素。你看它内容很短，就三个字，却占了一整行。没错，块元素就是这么任性。自习室一卷厕纸占一排座位。\n最后看第三行。浅绿色是一个块元素，深绿色是它内部的元素。所以元素之间是可以嵌套的，无论多么复杂的页面，都是这样一层层嵌套形成的。但是要注意，块元素内可以嵌入行内元素和块元素，行内元素只能嵌入行内元素。请看其中的深绿色部分，第二行是一个块元素，设定了宽度，并且居中排列。其实前两个行内元素的右边明明有空间，而且右边还放得下一个行内元素。但即使如此，它还是要占一整行。\n当然，块元素这个独占一行的特性有例外，我们接下来就会说。\n浮动 刚才讲的是常规的布局方式，我们现在讲两种打破常规的方式。\n浮动有两个方向，向左和向右。被加上了浮动属性的元素，表现都会变得类似于行内元素，根据内容变化尺寸。第一行的左右浮动元素都可以是块元素，但它们却排在了一行里。\n第二行和第三行是一组对比，表现了非浮动元素与浮动元素混合排列时的规则。第二行的文字是一个常规布局的元素，可以看到左右浮动的元素各就各位，常规布局的文字很灵活地填充空隙，就像报纸排版一样。而第三行里的情况，文字段落也加上左浮动属性，并且限定宽度，它就会跟在左浮动元素的右侧。\n当然，如果文字不限定宽度，它还是会独占一行，因为文字足够多。这和块元素独占一行的道理不同，它仍然带有浮动属性，本应该跟在左浮动元素的右边。只是因为自身宽度太大，一行挤不下了。\n绝对定位 另一种打破常规的布局方式是绝对定位。这就毫无章法可言了，像狗皮膏药一样想贴哪里贴哪里，还可以像图里这样层叠着贴。总之，绝对定位的元素不会占据常规布局和浮动布局中的任何空间，而是直接挡住它背后的内容。\n不过既然可以层叠，就有谁在前谁在后的问题。这和设计工具里的图层是一样的，当然有办法可以控制。\n一个页面是如何搭建出来的 http:\/\/v.youku.com\/v_show\/id_XMjY0ODI3OTAyMA==.html","author":{"@type":"Person","name":"Victor42"},"publisher":{"@type":"Organization","name":"Victor42","logo":{"@type":"ImageObject","url":"favicon.ico"}},"datePublished":"2017-03-19T00:46:29\u002b00:00","dateModified":"2017-03-19T00:46:29\u002b00:00","wordCount":8059,"timeRequired":"PT40M"}</script>
<link rel="shortcut icon" href=#ZgotmplZ>
</head><body class=article-page>
<script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script>
<div class="container main-container flex on-phone--column compact"><aside class="sidebar left-sidebar sticky">
<button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box>
<span class=hamburger-inner></span>
</span>
</button>
<header>
<figure class=site-avatar>
<a href=../../>
<img src=../../img/avatar_huda2458f72ce188392d75c5d51cd8e24e_373_300x0_resize_box_3.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a>
</figure><div class=site-meta>
<h1 class=site-name><a href=../../>Victor42</a></h1><h2 class=site-description>科学、纪录片、博物馆爱好者；Excel狂魔；蹩脚开发者；UI/UX设计师；生活观察者</h2></div></header><ol class=menu id=main-menu>
<li>
<a href=../../page/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>归档 - Archives</span>
</a>
</li><li>
<a href=../../page/about/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>关于我 - About</span>
</a>
</li><div class=menu-bottom-section>
<li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span>
</li></div></ol></aside><main class="main full-width">
<article class=main-article>
<header class=article-header>
<div class=article-details>
<header class=article-category>
<a href=../../categories/%E6%8A%98%E8%85%BE%E4%B8%8E%E6%80%9D%E8%80%83-geek/>
折腾与思考-Geek
</a>
</header><div class=article-title-wrapper>
<h2 class=article-title>
<a href=../../post/3545/>组件化设计与开发</a>
</h2></div><footer class=article-time>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published datetime=2017-03-19T00:46:29Z>Mar 19, 2017</time>
</div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>
40 minute read
</time>
</div></footer></div></header><section class=article-content>
<p>终于迎来一期特刊。最近打算在公司内部做一个分享，讲的是组件化的设计与开发的思维方式。准备完演讲资料，发现这完全可以改成一篇文章。藏着掖着不合适，发出来分享给有需求的朋友吧，就当是个试讲了，希望大家帮忙指出错误。</p><p>下载地址：
<a class=link href=https://www.jianguoyun.com/p/Df4KevYQwKOaBhjO8r0EIAA target=_blank rel=noopener>https://www.jianguoyun.com/p/Df4KevYQwKOaBhjO8r0EIAA</a></p><p>由于本文首先是以keynote的形式诞生的，其中还有动画和视频，所以我比较推荐大家直接下载keynote文件（也存了PPT版本）。内容和本文是一样的，但有些逻辑关系还真得让画面动起来才说得清。提醒一下，keynote文件大小将近150mb，嫌麻烦的朋友，当然也欢迎继续阅读。</p><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_1.png loading=lazy></p><h2 id=组件化>组件化</h2><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_2.png loading=lazy></p><p>组件化的工作方式信奉独立、完整、自由组合。目标就是尽可能把设计与开发中的元素独立化，使它具备完整的局部功能，通过自由组合来构成整个产品。</p><p>对于计算机这么复杂的工业产品，组件化是唯一能使它成为现实的方法。我中学暑假去电脑城打工，跟着别人学习电脑维修。CPU在哪里，负责什么，如何拆装；内存在哪里，负责什么，如何拆装。这些都是基础知识，各部分各司其职，什么坏了就换什么。我还见过资深维修工修主板，他真的能找出主板上哪个电容爆了，换一个相同规格的上去，电脑又能正常开机了。</p><h3 id=对产品设计的意义>对产品设计的意义</h3><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_3.png loading=lazy></p><p>当然今天我们不讲电脑维修，组件化思维要运用到我们的工作中。首先要了解，它对设计和开发到底有什么意义？</p><p>这部分虽然讲的是设计，但对开发同学也有价值。你们能了解设计师在做设计时的思路，说直白点就是摸清楚我们的套路。其实我们做设计的时候会有系统的考虑，并不是天马行空，想一出是一出。</p><h4 id=符合功能逻辑>符合功能逻辑</h4><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_4.png loading=lazy></p><p>组件化的设计恰恰是符合产品功能逻辑的。特定类型的信息，就有特定的最优展现方式和交互方式，这叫做设计模式。设计模式就应该提取出来作为组件。</p><p>比如要从多个维度快速检索和对比大量数据，没有什么能比表格形式效率更高。想象一下，上面这个界面的表格数据，做成卡片式堆叠在一起，划一张换一条，或者像淘宝商品列表那样，一行4列平铺开。那还对比个P啊，用户都要摔鼠标了。</p><h4 id=保持交互一致性>保持交互一致性</h4><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_5.png loading=lazy></p><p>交互的一致性，或者说可预测性，是用户体验的根本。比如日期选择组件，在整个产品中就应该只有一种存在形式。如果一会儿是滚轮拨盘，一会儿是日历，一会儿又是下拉列表，这样的设计绝对是不能上线的。</p><h4 id=保持视觉风格统一>保持视觉风格统一</h4><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_6.png loading=lazy></p><p>这部分主要是视觉方面的考虑，更多样式上的差异。不同的样式会给产品带来不同的调性。</p><p>就拿按钮来说。圆头造型表现出一种柔和亲切的特质，同时有利于将注意力聚焦到其中内容上。而直角则展现出一种棱角分明的硬朗，边界更加清晰。想一想三星手机和锤子手机的外观造型，两种截然不同的感觉。</p><p>为了保持产品视觉风格统一，设计师应该找到最合适的方案，并处处保持统一，不可以太随心所欲。</p><h4 id=便于多设计师协作>便于多设计师协作</h4><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_7.png loading=lazy></p><p>组件化设计是大型设计项目的必要条件。比如两位设计师协作，一个在设计注册界面，一个在设计修改密码界面，或者在设计某个问卷调查的弹窗。这其中都有表单，两个人设计出来不一样怎么办？一个边框颜色深一点，一个边框颜色浅一点？其实没理由不同，应该保持一致。口头约定太麻烦，而且难以保证执行到位，组件化是最好的解决方式。</p><h4 id=便于修改设计>便于修改设计</h4><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_8.png loading=lazy></p><p>设计总是要修改优化的，有些改动牵扯全局，动静非常大。</p><p>比如管理后台的界面，左侧的主导航是全站通用的。某天决定要给它换一套浅色的设计，难道每个PSD都改一遍吗？如果产品逻辑复杂，PSD有上百个呢？</p><h3 id=对开发的意义>对开发的意义</h3><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_9.png loading=lazy></p><p>下面讲讲组件化对开发的意义。其实开发同学从中受益比设计师更多。</p><h4 id=降低耦合度>降低耦合度</h4><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_10.png loading=lazy></p><p>降低耦合度，相信这是大型项目都在追求的。</p><p>举个例子，如果要把页面的body区域加宽。内部许多元素因为浮动、固定宽度、百分比宽度、文字行数减少等等，布局会乱套。就像这图里这样，这是因为内部模块的样式对页面父级元素存在依赖和继承。</p><p>可能有人会觉得并不存在依赖关系，但其实固定宽度本身就是一种依赖关系。假如说页面主体部分宽度1000px，左侧边栏200px，右侧800px。没错，这是按设计图来做的。那这个800px宽是怎么得出的？正是因为页面主体宽度1000px，才找了个合适的左右比例，设计成这样的。所以无可避免，从设计这个环节开始就产生了依赖关系。</p><p>像这种情况，我宁可在模块外面多套一层容器，模块本身的宽度写成100%，外面那层容器属于框架布局，具体宽度写在它上面。虽然DOM树变复杂了，但内外的布局逻辑被分离了。</p><h4 id=减少冗余>减少冗余</h4><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_11.png loading=lazy></p><p>比方说要新增一个带表格的界面，开发同学按照设计的效果图一行行写页面。但是如果在某个已有界面中就存在表格？或许当时是另一位开发同学做的。相比重新写一遍，把代码要过来直接用更方便一点吧？</p><p>如果表格样式之后又要改呢，是不是两个地方都得改。如此一来，用到表格的页面越多，就越容易漏改。而且静态资源服务器上存了太多份关于表格的样式，其中内容明明是一样的。</p><h4 id=优化性能>优化性能</h4><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_12.png loading=lazy></p><p>优化性能刚好可以接着上一条说。</p><p>那么多份表格的样式，客户端每打开一个新的表格页面，就得加载一次。占用带宽，浪费了缓存资源。虽然一两个的影响几乎感受不到，但这种情况一多，就会对用户体验产生明显的影响。</p><p>慢，是用户体验的头等大忌，没有之一。</p><h4 id=便于多开发协作>便于多开发协作</h4><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_13.png loading=lazy></p><p>这和设计师协作的道理相同。</p><p>如果两个开发同学都在制作带有下拉菜单的页面，这部分工作只要交给其中一人就行了。TA做好之后封装成组件，另一位开发在自己的页面中加载就行了。</p><h4 id=便于查错>便于查错</h4><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_14.png loading=lazy></p><p>便于查错，是耦合性降低的一个副产品。它可以大大加快错误排查的速度。</p><p>如果页面上出现问题，可以找出每个可能有关的组件，逐个拔除，直到恢复正常。这样就能迅速锁定错误发生的位置。同时组件内也可以形成完整的自测单元，也方便了测试工作。</p><h4 id=便于修改>便于修改</h4><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_15.png loading=lazy></p><p>假如设计师每个页面改同一个地方要花一个小时，那开发做同样的事情至少要花一个上午，至少。</p><p>封装成组件，可以把这个时间缩短到10分钟。毕竟不用去改几十个页面的HTML、CSS和JS，改一个组件就可以了。</p><h2 id=布局原理>布局原理</h2><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_16.png loading=lazy></p><p>讲了组件化的意义，本来顺理成章应该讲组件化的具体做法。但在这之前其实有必要插入这一块内容，帮助没有前端基础的设计师了解，开发是如何把页面搭建起来的。</p><p>大家可以先有一个粗略的想象，就像是重力朝上的俄罗斯方块。页面元素都是从下往上这样一行一行搭出来的，不过这个玩家有强迫症，他一定会从左上角、右上角或者中间位置搭起。当然……搭满一行并不会消除。 ¯\<em>( ツ )</em>/¯</p><h3 id=行内元素与块元素>行内元素与块元素</h3><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_17.png loading=lazy></p><p>网页布局中有两个概念：行内元素和块元素。它们是非此即彼的关系，网页里只要是你能看见的东西，一定不是行内元素就是块元素。</p><p>这两种元素的表现略有不同。虚线框代表一行，但实际上这是不可见的，只是我为了说明布局方式画出来的，其中的绿色矩形才是页面上真实可见的元素。</p><p>我们看第一行，这里有3个行内元素。内容长度不同，它们表现出来的宽度就不同，这是一种会随内容变化而改变尺寸的布局单元，而且它们总是从左到右横向排列，只要一行里排得下。</p><p>再看第二行，这里只有1个块元素。你看它内容很短，就三个字，却占了一整行。没错，块元素就是这么任性。自习室一卷厕纸占一排座位。</p><p>最后看第三行。浅绿色是一个块元素，深绿色是它内部的元素。所以元素之间是可以嵌套的，无论多么复杂的页面，都是这样一层层嵌套形成的。但是要注意，块元素内可以嵌入行内元素和块元素，行内元素只能嵌入行内元素。请看其中的深绿色部分，第二行是一个块元素，设定了宽度，并且居中排列。其实前两个行内元素的右边明明有空间，而且右边还放得下一个行内元素。但即使如此，它还是要占一整行。</p><p>当然，块元素这个独占一行的特性有例外，我们接下来就会说。</p><h3 id=浮动>浮动</h3><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_18.png loading=lazy></p><p>刚才讲的是常规的布局方式，我们现在讲两种打破常规的方式。</p><p>浮动有两个方向，向左和向右。被加上了浮动属性的元素，表现都会变得类似于行内元素，根据内容变化尺寸。第一行的左右浮动元素都可以是块元素，但它们却排在了一行里。</p><p>第二行和第三行是一组对比，表现了非浮动元素与浮动元素混合排列时的规则。第二行的文字是一个常规布局的元素，可以看到左右浮动的元素各就各位，常规布局的文字很灵活地填充空隙，就像报纸排版一样。而第三行里的情况，文字段落也加上左浮动属性，并且限定宽度，它就会跟在左浮动元素的右侧。</p><p>当然，如果文字不限定宽度，它还是会独占一行，因为文字足够多。这和块元素独占一行的道理不同，它仍然带有浮动属性，本应该跟在左浮动元素的右边。只是因为自身宽度太大，一行挤不下了。</p><h3 id=绝对定位>绝对定位</h3><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_19.png loading=lazy></p><p>另一种打破常规的布局方式是绝对定位。这就毫无章法可言了，像狗皮膏药一样想贴哪里贴哪里，还可以像图里这样层叠着贴。总之，绝对定位的元素不会占据常规布局和浮动布局中的任何空间，而是直接挡住它背后的内容。</p><p>不过既然可以层叠，就有谁在前谁在后的问题。这和设计工具里的图层是一样的，当然有办法可以控制。</p><h3 id=一个页面是如何搭建出来的>一个页面是如何搭建出来的</h3><p><a class=link href="http://v.youku.com/v_show/id_XMjY0ODI3OTAyMA==.html" target=_blank rel=noopener><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_20.png loading=lazy></a></p><p><a class=link href="http://v.youku.com/v_show/id_XMjY0ODI3OTAyMA==.html" target=_blank rel=noopener>http://v.youku.com/v_show/id_XMjY0ODI3OTAyMA==.html</a></p><p>我做了一个动画演示，大家感受一下页面搭建的大致原理。</p><h3 id=流式布局>流式布局</h3><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_21.png loading=lazy></p><p>现在要讲的是两个更宏观的概念：流式布局与弹性布局。</p><p>我们前面有提到常规布局，那个概念与这两者不能相提并论。其实这两种布局都是基于前面提到的原理实现的，只是区别在于对待自适应问题上采取了不同的策略。</p><p>看图中的App store界面，在iPhone 7和7 plus上略有不同。虽然布局形式类似，但7上面只能看到一张banner，而7 plus则能看到左右两边banner露出来。而且App展示区域里，7上能看到3列多一点，7 plus则能看到4列多。屏幕大则视野更大，能显示更多内容，这是流式布局的思想。</p><h3 id=弹性布局>弹性布局</h3><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_22.png loading=lazy></p><p>弹性布局则是另一种思路。根据屏幕尺寸变化，让界面上所有元素等比例放大缩小。所以无论在什么尺寸的设备上，看到的画面都是一样的，信息容量相同。只是到了大屏幕上，会变得像老年手机那样硕大无比。</p><p>这两种自适应方式都有各自的用途，不能说哪种一定更好。但我们在设计时可以考虑一下这个问题，什么类型的设计适合哪种布局。</p><h2 id=组件化设计>组件化设计</h2><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_23.png loading=lazy></p><p>补完了基础知识，现在就可以讲组件化设计的具体方法了。</p><h3 id=提取产品中的共用部分>提取产品中的共用部分</h3><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_24.png loading=lazy></p><p>首先要提取产品中的共用部分。我列举了一些，这些都是极为常见的组件。</p><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_25.png loading=lazy></p><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_26.png loading=lazy></p><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_27.png loading=lazy></p><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_28.png loading=lazy></p><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_29.png loading=lazy></p><p>这个翻页其实有点问题，少了个当前选中状态，不知道现在是第几页啊。所以说组件的提取要考虑周全，所有可能的状态都要设计。</p><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_30.png loading=lazy></p><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_31.png loading=lazy></p><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_32.png loading=lazy></p><h3 id=制作成通用组件>制作成通用组件</h3><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_33.png loading=lazy></p><p>找到了这些共用元素，下面到具体制作环节，关于工具的使用我不会讲太多，主要是思路与观念。我用Sketch录了3段操作演示，我们边看边讲。</p><h4 id=sketch-symbol>Sketch Symbol</h4><p><a class=link href="http://v.youku.com/v_show/id_XMjY0ODI2MDA0MA==.html" target=_blank rel=noopener><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_34.png loading=lazy></a></p><p><a class=link href="http://v.youku.com/v_show/id_XMjY0ODI2MDA0MA==.html" target=_blank rel=noopener>http://v.youku.com/v_show/id_XMjY0ODI2MDA0MA==.html</a></p><p>这段视频是讲Sketch中组件的使用。</p><p>我们把这个列表项提取为一个组件，现在看其实没什么变化。我们先复制几个出来，让它成为一个列表。然后我们到组件页面去，发现刚才提取的组件就在这里。我们尝试把圆形的头像改成方形，嗯，去掉边框。回到列表界面来，发现整个列表的头像都变成方形了，但我们只在组件里做了一次修改，就达到这样的效果。</p><h4 id=sketch-overrides>Sketch Overrides</h4><p><a class=link href="http://v.youku.com/v_show/id_XMjY0ODI1ODUyNA==.html" target=_blank rel=noopener><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_35.png loading=lazy></a></p><p><a class=link href="http://v.youku.com/v_show/id_XMjY0ODI1ODUyNA==.html" target=_blank rel=noopener>http://v.youku.com/v_show/id_XMjY0ODI1ODUyNA==.html</a></p><p>这段视频是讲如何把组件的样式与内容分离开。</p><p>还是刚才的组件，不过我把头像右边代表两行文字的矩形换成了真正的文字，我要把它当作通讯录界面来设计。现在我们回到列表界面，发现列表里每一项都变成了姓名+电话号码。然后我们在每一项的Overrides选项中输入数据，因为这是在组件之外输入的信息，它只会影响那一条内容。用这种方式把每个列表项都填上数据。现在我们再进到组件里，做点样式修改，比如把电话号码颜色改成灰色。回到列表，所有电话号码都变灰了，内容保持不变。</p><p>这样就实现了样式与内容的分离，降低耦合度对设计同样适用。</p><h4 id=sketch-symbol-的嵌套>Sketch Symbol 的嵌套</h4><p><a class=link href="http://v.youku.com/v_show/id_XMjY0ODI2Mjc2OA==.html" target=_blank rel=noopener><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_36.png loading=lazy></a></p><p><a class=link href="http://v.youku.com/v_show/id_XMjY0ODI2Mjc2OA==.html" target=_blank rel=noopener>http://v.youku.com/v_show/id_XMjY0ODI2Mjc2OA==.html</a></p><p>这段视频是讲组件的嵌套。</p><p>组件小的可以只有一个按钮，大的可以是一个交互极其复杂的多步筛选项。所以复杂组件内再嵌入简单组件，这是很常见的事情。</p><p>我给刚才的组件又增加了一个按钮，我们把这个按钮也提取成组件，可以看到它出现在了列表项组件的右侧。回到列表界面，每个列表项都有了按钮，我们选中所有列表项，把按钮文字成呼叫。然后右边还有另一个界面，这里也需要一个按钮。我们在此插入之前提取的按钮组件，把按钮文字改为订阅。如此一来，按钮组件就既存在于界面中，也存在于其他组件中。这时候如果想对按钮的样式做点调整，我们再进入按钮组件，改成灰底白字。回到界面中，发现各处按钮都一起变了。</p><p>组件化的思想不限于设计工具，虽然Sketch很先进，很利于实现这种工作方式。但PS也有相应的功能，能够以另一种形式实现组件化。</p><h3 id=一个组件就是一个完整的产品>一个组件就是一个完整的产品</h3><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_37.png loading=lazy></p><p>设计组件不是把它搬到另一个地方，然后各处集中引用这么简单。开头我们就说过，组件化思维的精髓是独立、完整、自由组合。刚才我们做到了独立，同时也需要做到完整。</p><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_38.png loading=lazy></p><p>就拿按钮来说，我们必须考虑它的各种状态、极端情况、尺寸变化，还有所有附带的交互效果。这才能称之为一个独立完整的组件，满足其他组件对一个按钮的所有要求。
除了最标准的默认、按下、禁用状态，还要考虑按钮的尺寸变化，发生服务器交互时每个状态的样式，还有特殊按钮内容的展示效果。</p><h3 id=思考相互间的组合方式>思考相互间的组合方式</h3><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_39.png loading=lazy></p><p>组件内部完整了，接下来就是自由组合了。但并不是真的那么自由，我们要确定一些常用的组合方式。</p><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_40.png loading=lazy></p><p>像这样一个后台管理界面：页面的整体背景色，主菜单与右侧内容的距离，输入框之间的距离……这些也都要有章法。</p><h3 id=形成规范文档>形成规范文档</h3><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_41.png loading=lazy></p><p>以上这些工作，沉淀下来，就成了设计规范。这套文档对项目中的其他设计师是莫大的帮助，也是开发人员重要的资料。</p><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_42.png loading=lazy></p><p>组件化设计是一切的源头，如果我们设计部分的组件化工作做得不到位，自己定的规范自己不遵守，开发的同学的组件化工作是无法进行的。</p><h2 id=开发组件化>开发组件化</h2><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_43.png loading=lazy></p><p>讲完设计组件化，现在我们来讲一下开发的组件化。</p><h3 id=按组件而不是页面来开发>按组件，而不是页面来开发</h3><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_44.png loading=lazy></p><p>最重要的一点，是需要转变一个观念。我们应该以组件为单位，而不是以页面为单位进行开发。</p><h3 id=轻度组件化>轻度组件化</h3><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_45.png loading=lazy></p><p>组件化开发有两种不同程度的做法。</p><p>先讲讲轻度组件化。它的主要思想是使用相同的html结构和特定的class名，并且用同一段css代码定义样式，用同一个js函数来定义交互。</p><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_46.png loading=lazy></p><p>我们来看看上面这个登录框，下面3个代码块是它大致的代码结构。输入框在其他页面肯定也会用到，那么只需要与左边框里的html结构保持一致。各处页面代码中引用同一个css和js文件，至少做到了在一处集中管理样式与交互。但如果组件的html结构发生变化，修改的工作量还是会比较大。</p><h3 id=重度组件化>重度组件化</h3><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_47.png loading=lazy></p><p>重度组件化的方式可以解决这个问题，不过这就不仅仅停留在思想层面，对项目的代码结构都有一定的要求。</p><p>每个组件的html结构、css样式、js交互都独立封装管理，定义好框架和加载方式，内容在加载时从外部填充。</p><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_48.png loading=lazy></p><p>在重度组件化的项目中，每个组件都做到了彻底的独立封装。比如这个页头组件，它的代码存在于独立的目录下，这个目录包含了它的html结构、css样式、js交互、资源图、甚至自测试模块。</p><p>那么各处页面中要加载页头组件，往往只是一条语句，将数据传入这个已存在的结构中就行了。</p><p>组件如果要与外部进行数据传递，也应该以接口形式对外开放。组件内部是个黑盒，外部只需要了解数据的输入与返回，不必关心组件内的工作原理。</p><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_49.png loading=lazy></p><p>用这种思路管理项目，也会改变开发的协作方式。大家不再是按页面分工，而是按组件来分工。页头和tab由一人负责，列表和页脚由另一个人负责，弱化了相互间的依赖关系。直到将组件拼装成页面，才需要处理组件之间相互作用的部分，但这时候工作量已经被大大消化了。</p><p><a class=link href="http://v.youku.com/v_show/id_XMjY0ODI1NzI0MA==.html" target=_blank rel=noopener><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_50.png loading=lazy></a></p><p><a class=link href="http://v.youku.com/v_show/id_XMjY0ODI1NzI0MA==.html" target=_blank rel=noopener>http://v.youku.com/v_show/id_XMjY0ODI1NzI0MA==.html</a></p><p>我们可以来感受一下组件化管理的项目，应该是个什么样的结构。</p><p>一个应用由大量页面组成。一个页面的绝大部分都是组件。组件内部已经定义好了完整的结构，可以独立运行。纵观整个项目，可能就会是这样一个结构。组件的代码占了大多数，能共用的都尽量共用，各个页面的特殊代码则会变得非常轻。各功能模块的划分清晰明确，一目了然。</p><h2 id=重在维护>重在维护</h2><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_51.png loading=lazy></p><p>虽然前面说了这么多好处，但组件化不是一件轻松的工作。在项目初期的准备工作会增加一定工作量，但随时间推移会发挥出巨大的优势。</p><p>想象一下，像windows操作系统这种航母级的开发项目，如果不用组件化的方式来管理，它有可能成为现实吗？</p><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_52.png loading=lazy></p><p>我们设计师要做的，就是要有专人负责维护设计组件库。组件发生了任何设计修改，或者加入了新组件，都要及时反映在设计规范上。</p><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_53.png loading=lazy></p><p>开发同学也需要指定人员来负责维护具体的组件。他们要做的，我就不好多说了，毕竟我不是专业的。</p><p>但可以举个例子，像Google Ara项目的这款模块化手机一样：摄像头模块只负责拍照，处理照片得交给运算模块；而GPS模块只负责定位相关功能，导航语音播报则需要发声模块来处理。任何模块的拆换，对其余模块的运转毫无影响。</p><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_54.png loading=lazy></p><p>双方的维护工作固然重要，更重要的是沟通交换信息。有任何变化都要及时告知对方，组件的高度同步，是这种工作方式得以长期延续的关键。</p><h2 id=组件化思维>组件化思维</h2><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_55.png loading=lazy></p><p>我们跳出工作的范畴，跳出刚才这些条条框框，单纯想一想组件化这种思想。其实它可以用来理解生活的方方面面。</p><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_56.png loading=lazy></p><p>它的精髓就是这么3点：独立、完整、自由组合。我们生活中见到的绝大多数工业产品，就是这么造出来的，比如汽车工业，比如富士康的iPhone生产线。甚至部队的编制也是遵循这个原理。</p><p>而且组件化甚至都不算是人类的发明。即使放在自然界，这也是早已存在的模式。想想我们人体多么复杂，绝对不亚于windows操作系统。但除去极少数器官之外，任何部分损坏或缺失，我们都能活下来。这不得不说是组件化的奇迹。</p><p><a class=link href=https://v.qq.com/x/page/e0350h51dga.html target=_blank rel=noopener><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_57.png loading=lazy></a></p><p><a class=link href=https://v.qq.com/x/page/e0350h51dga.html target=_blank rel=noopener>https://v.qq.com/x/page/e0350h51dga.html</a></p><p>最后，我想给大家看一段1分钟的视频。这是宜家厨房的宣传片，宜家是一家高度推崇组件化的公司。不仅仅是用在生产流程中，也把组件化思维从幕后推向了台前，成为了自己品牌的一种语言。</p><p>我们来直观感受一下，让组件化的思想在你脑海中留下一个具象的画面。</p><p><img src=../../https:/cdn.victor42.work/posts/2017-03/03-18/pic_58.png loading=lazy></p><p>部分资料引自《前端工程——基础篇》
<a class=link href=https://github.com/fouber/blog/issues/10 target=_blank rel=noopener>https://github.com/fouber/blog/issues/10</a></p></section><footer class=article-footer>
</footer></article><footer class=site-footer>
<section class=copyright>
&copy;
2025 Victor42
</section><section class=powerby>
Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> <br>
Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.16.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a>
</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true>
<div class=pswp__bg></div><div class=pswp__scroll-wrap>
<div class=pswp__container>
<div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden">
<div class=pswp__top-bar>
<div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class=pswp__preloader>
<div class=pswp__preloader__icn>
<div class=pswp__preloader__cut>
<div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class=pswp__caption>
<div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous>
</main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=../../ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script>
</body></html>